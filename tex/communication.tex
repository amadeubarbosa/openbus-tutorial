Neste capítulo são apresentados os recursos de comunicação entre sistemas integrados através da infraestrutura do \openbus{}, que basicamente se resumem aos recusos estabelecidos pelo padrão CORBA.
Portato neste capítulo é apresentada uma visão geral do desenvolvimento de sistemas distribuídos usando a tecnologia CORBA.
%Todos os exemplos são elaborados de forma incremental para formar ao final uma integração completamente funcional sobre a infraestrutura do \openbus{}.

\section{Introdução ao CORBA}

A base da tecnologia \openbus{} é o padrão CORBA para desenvolvimento de sistemas distribuídos orientados a objetos.
Para ilustrar o uso de CORBA tomemos como exemplo o programa apresentado na figura~\ref{fig:ex01:matrices/Application}.
Esse programa utilizada uma biblioteca de multiplexação de matrizes (linha~\ref{lin:ex01:matrices/Application:matrix}) para calcular uma transformação (linha~\ref{lin:ex01:matrices/Application:multiply}) no vetor gerado pelo programa (linha~\ref{lin:ex01:matrices/Application:makevector}) que é exibida ao final (linha~\ref{lin:ex01:matrices/Application:print}).

\inputexsrc{ex01}{matrices/Application}{Aplicação de multiplicação de matrizes.}

A figura~\ref{fig:monolithic} ilustra a estrutura de um programa monolítico com o nosso programa de multipliciação de matrizes da figura~\ref{fig:ex01:matrices/Application}.
No caso desse programa o cliente é o corpo principal do programa e o objeto sendo utilizado é a matriz criada na linha~\ref{lin:ex01:matrices/Application:matrix}.

\inputimage{monolithic}{Estrutura de uma aplicação monolítica.}

Agora suponhamos que a funcionalidade de multiplicação de matrizes não deva mais ser obtidia a partir de uma biblioteca local, mas sim como um serviço oferecido por um servidor remoto.
Neste caso, uma abodagem seria utilizar um intermediador de chamadas de objetos (ORB -- \term{Object Request Broker}) para permitir fazer chamadas a objetos remotos através de uma rede por exemplo, como ilustrado na figura~\ref{fig:orbapp}.
Na nomenclatura de CORBA, convenciona-se chamar de \term{servant} o objeto local que implementa um objeto distribuído, ou seja, acessível remotamente.

\inputimage{orbapp}{Aplicação distribuída usando um ORB.}

Contudo, é interessante notar que para essa abordagem ser possível é necessário que o ORB ofereça e implemente as mesmas interfaces específicas os objetos que devam se tornar remotos.
Para resolver isso o CORBA adota uma solução como ilustrada na figura~\ref{fig:ior}, onde o ORB oferece uma implementação e interface única (em azul: \term{ORB} e \term{POA}).
Para adaptar esse ORB único para diferentes aplicações é utilizado um gerador de código que tem como entrada uma descrição das interfaces dos objetos e gera um código na linguagem da aplicação que adapta o ORB às interfaces específicas dos objetos distribuídos (em verde: \term{Stub} e \term{Skeleton}).
Essa desrição das interfaces é feita numa linguagem definida por CORBA denominada IDL (\term{Interface Description Language}), que permite descrições de interfaces e tipos de forma independente de linguagens de programação.

\inputimage{ior}{Visão geral de uma aplicação CORBA.}

O ORB CORBA oferece elementos padrão denominados POA (\term{Portable Object Adaptor}) para gerência dos objetos distribuídos naquele ORB e dos servants que o implementam.
Ao contrário de objetos locais que podem ser referenciados apenas por um endereço de memória, os objetos distribuídos em CORBA são referenciados através de uma estrutura denominada IOR (\term{Interoperable Object Reference}).
O IOR tipicamente contem informações como o endereço da máquina e porta onde o ORB em que o objeto distribuído reside está e um identificador único daquele objeto no ORB denominado \term{Object ID}.
O \term{Object ID} de cada objeto distribuído pode ser gerado automaticamente pelo ORB no registro do servant, ou pode ser fornecido pela aplicação.

O \term{Skeleton} é o código gerado pelo compilador de IDL que adapta a interface especifica da aplicação provida pelo servant à implementação do ORB.
No lado dos clientes que acessam os objetos distribuídos temos um objeto local que representa o objeto distribuído, denominado \term{Stub}.
O \term{stub} também é implementado por código gerado pelo compilador de IDL e possui internamente uma referência (IOR) para o objeto distribuído que ele representa.

Para transformar a aplicação da figura~\ref{fig:ex01:matrices/Application} numa aplicação distribuída usando CORBA devemos inicialmente definir uma IDL que descreva a interface da instância de \code{matrix} que se tornará o objeto distribuído.
A figura~\ref{fig:ex02:matrices} ilustra uma descrição em IDL da interface do objeto \code{matrix} que é utilizado pelo programa da figura~\ref{fig:ex01:matrices/Application}.

\inputexidl{ex02}{matrices}{IDL de matrizes de transformação.}

%--- Java ----------------------------------------------------------------------
A compilação da IDL que define uma interface de nome \code{Foo} gera tipicamente o seguinte conjunto de arquivos Java:

\begin{center}
	\begin{tabular}{ll}
	Arquivo & Descrição \\
	\hline
	Foo.java & Interface com as operações de \code{Foo} e outras operações de objetos distribuídos CORBA. \\
	FooOperations.java & Interface apenas com as operações de \code{Foo}. \\
	FooPOA.java & Classe abstrata que deve ser estendida para implementar um servant que implemente as operações de \code{Foo}. \\
	FooPOATie.java & Classe que implementa um servant de \code{Foo}, mas que delega as operações para um objeto que implemente \code{FooOperations}. \\
	\_FooStub.java & Implementação interna dos objetos de \term{stub} de \code{Foo}. \\
	\end{tabular}
\end{center}

A figura~\ref{fig:idluml} ilustra a esturuta do código Java gerado pela compilação de uma IDL descrevendo uma interface denominada \code{Foo}.
As definições oferecidas pela implementação do ORB são exibidas em azul.
As definições em verde são as geradas pelo compilador de IDL.
As definições em amarelo são fornecidas pelo desenvolvidor da aplicação.
As definições esbranquecidas não são manipuladas diretamente pela aplicação.

\inputimage{idluml}{Estrutura do código Java gerado pela compilador de IDL.}

Para compilar o arquivo IDL \code{matrices.idl} usando o compilador de IDL do JDK utilize o seguinte comando:

\begin{samplecode}[language=bash]
	idlj -fallTIE matrices.idl
\end{samplecode}

De posse do código gerado pelo compilador de IDL podemos desenvolver um servidor CORBA que exporta um objeto distribuído que implemente a interface descrita na IDL, como ilustrado no código da figura~\ref{fig:ex02:matrices/Server}.
A classe \code{MatrixServant} (linha~\ref{lin:ex02:matrices/Server:servant}) basicamente é definida apenas para declarar que a classe \code{Matrix} da nossa biblioteca de multiplicação de matrixes suporta a interface \code{SquareMatrix} declarada em IDL.
Com essa classe \code{MatrixServant} podemos criar um objeto \code{SquareMatrixPOATie}, que é uma classe de conveniência gerada pelo compilador de IDL (opção \code{-fallTIE}) que implementa um servant da interface \code{SquareMatrix} mas que delega toda sua implementação para um objeto que implementa as operações dessa interface (\code{SquareMatrixOperations}).
Portanto, a instância de \code{SquareMatrixPOATie} criada na linha~\ref{lin:ex02:matrices/Server:poatie} funcionará como um servant que delega suas chamadas para uma instância de \code{MatrixServant}.
Como \code{MatrixServant} incorpora a implementação da classe \code{Matrix} da biblioteca local utilizada no nosso exemplo, teremos que o objeto distribuído será efetivamente uma versão distribuída do objeto \code{matrix} da nossa versão monolítica da aplicação de exemplo.

\inputexsrc{ex02}{matrices/Server}{Servidor CORBA de uma matriz de transformação.}

Um servidor CORBA deve inicialmente inicializar um ORB (linha~\ref{lin:ex02:matrices/Server:initorb}), que aloca os recursos necessários para seu funcionamento, tal como uma porta TCP para receber chamadas remotas.
Por essa razão, uma vez iniciado o ORB deve ser encerrado adequadamente ao final do seu uso (linha~\ref{lin:ex02:matrices/Server:shutorb}).

Para criar um novo objeto distribuído usando o ORB é necessário antes obter um POA (linha~\ref{lin:ex02:matrices/Server:getpoa}).
Nesse exemplo, utilizamos o \code{RootPOA}, que é um POA criado automaticamente pelo ORB na sua inicialização e disponibilizado através da operação \code{resolve\_initial\_references} do ORB.
Como a operação \code{resolve\_initial\_references} devolve um objeto \code{org.omg.CORBA.Object}, é necessário realizar uma coerção para o tipo \code{org.omg.PortableServer.POA} antes de poder utilizá-lo.
Essa coerção deve ser feita através de operações $<$\textit{Interface}$>$\code{Helper.narrow} provenientes da infraestrutura oferecida pelo CORBA\footnote{Ou pela implementação padrão do ORB ou código gerado pelo compilador de IDL}.
As operações de coerção funcionam de forma similar ao operador de \term{typecasting} de Java, mas permitem a coerção adequada de objetos da infraestrutura de CORBA, em particular aqueles que implementam a interface \code{omg.orb.CORBA.Object}.

Para que os objetos registrados num dado POA possam receber chamadas, o POA deve ser ativado (linha~\ref{lin:ex02:matrices/Server:activatepoa}).
A operação \code{servant\_to\_reference} do POA (linha~\ref{lin:ex02:matrices/Server:regobj}) é usada para criar um objeto distribuído a partir do registro um servant no POA com um \term{Object ID} gerado automaticamente pelo ORB.
Adicionalmente, essa operação também já devolve um \term{stub} que referencia o objeto distribuído criado.

O que resta resolver nesse exemplo é como transmitir essa referência do objeto distribuído para o programa cliente.
Uma maneira utilizar o suporte de serialização de referências de objetos distribuídos CORBA para texto, que é feito através da operação \code{object\_to\_string} (linha~\ref{lin:ex02:matrices/Server:printior}).
Com esse texto é possível recriar a referência ao objeto distribuído em qualquer programa com suporte CORBA.
Por fim, o programa do servidor fica aguardando uma entrada qualquer apenas para saber quando deve terminar seu funcionamento (linha~\ref{lin:ex02:matrices/Server:waitend}).

O código da figura~\ref{fig:ex02:matrices/Application} ilustra o código alterado do exemplo da figura~\ref{fig:ex01:matrices/Application} para acessar o objeto distribuído disponibilizado pelo progama servidor da figura~\ref{fig:ex02:matrices/Server}.
De forma similar ao programa servidor, o programa cliente também deve inicializar um ORB (linha~\ref{lin:ex02:matrices/Application:initorb}) e encerrá-lo ao final de seu uso (linha~\ref{lin:ex02:matrices/Application:shutorb}).
O programa lê da entrada padrão (linha~\ref{lin:ex02:matrices/Application:readior}) um texto que deve conter a serialização da referência do objeto \code{SquareMatrix} que deve ser utilizado.
Essa referência textual é então utilizada para criar um \term{stub} para o objeto distribuído usando a operação \code{string\_to\_object} (linha~\ref{lin:ex02:matrices/Application:createstub}).
O restante do programa permance inalterado já que a interface do objeto distribuído é idêntica a interface do objeto \code{matrix} da versão original.

\inputexsrc{ex02}{matrices/Application}{Aplicação CORBA que utiliza serviço de matriz de transformação.}
%-------------------------------------------------------------------------------

\section{Descrição de Interfaces em IDL}

A linguagem de descrição de IDL de CORBA tem suporte a diversos tipos de dados para descrição dos valores manipulados pelas interfaces.
A seguir são apresentados brevemente alguns dos principais recursos de descrição de tipos e interfaces da linguagem IDL de CORBA.

\paragraph{Tipos Primitivos} são valores mais básicos que muitas vezes são combinados para formar outros tipos mais complexos. A tabela da figura~\ref{fig:idlprimitives} lista os tipos mais primitivos em IDL e como eles são mapeados para a tipos da linguagem Java.

\begin{figure}
	\caption{Mapeamento dos tipos primitivos de IDL para Java}\label{fig:idlprimitives}
	\begin{tabular}{l|l|l}
		Tipo IDL & Tipo Java & Descrição \\
		\hline
		boolean & boolean & \code{true} ou \code{false} \\
		char & char & caracter de 1 byte \\
		wchar & char & caracter de 2 bytes \\
		octet & byte & inteiro em 1 byte \\
		string & java.lang.String & cadeia de carac. de 1 byte \\
		wstring & java.lang.String & cadeia de carac. de 2 bytes \\
		short & short & inteiro de 2 bytes \\
		unsigned short & short & int. não-neg. de 2 bytes \\
		long & int & inteiro de 4 bytes \\
		unsigned long & int & int. não-neg. de 4 bytes \\
		long long & long & inteiro de 8 bytes \\
		unsigned long long & long & int. não-neg. de 8 bytes \\
		float & float & ponto-flut. de prec. simples \\
		double & double & ponto-flut. de prec. dupla \\
		fixed & java.math.BigDecimal & decimal em ponto fixo \\
	\end{tabular}
\end{figure}

\paragraph{Enumeração} descrevem tipos cujo valores possíveis são restritos a um conjunto pequeno.
\begin{samplecode}[language= {[CORBA]IDL} ]
enum Color { red, green, blue };
enum Size { small, medium, large };
\end{samplecode}

\paragraph{Arranjo} descrevem tipos cujo valores são sequências de tamanho fixo de valores de um mesmo tipo.
\begin{samplecode}[language= {[CORBA]IDL} ]
double Vetor3D[3];
\end{samplecode}

\paragraph{Sequência} descrevem tipos cujo valores são sequências de tamanho variados de valores de um mesmo tipo.
\begin{samplecode}[language= {[CORBA]IDL} ]
sequence<long> LongIntegers;
sequence<Color> Colors;
\end{samplecode}

\paragraph{Estrutura} descrevem tipos cujo valores são estruturas compostas por um conjunto finito de campos de tipos determinados.
\begin{samplecode}[language= {[CORBA]IDL} ]
struct Foo {
	long some_value;
	double other_value;
	string another_value;
	Color yet_another_value;
};
\end{samplecode}

\paragraph{União} são tipos cujo valores são estruturas com um único campo que pode ser de diferentes tipos dependendo do valor de um discriminante especial, que em geral é uma enumeração ou tipo numérico.
Na prática, uma união é composta por dois valores, o valor do discriminante e o valor do campo que tem o tipo variado de acordo com o valor do discriminante.
No exemplo abaixo, quando o valor do discriminante é \code{NUM\_VALUE} o campo da união é \code{num\_val} que assume valores do tipo \code{double}.
\begin{samplecode}[language= {[CORBA]IDL} ]
enum ValueKind { BOOL_VALUE, NUM_VALUE, TXT_VALUE };
union Value switch (ValueKind) {
	case BOOL_VALUE: boolean bool_val;
	case NUM_VALUE: double num_val;
	case TXT_VALUE: string txt_val;
};
\end{samplecode}

\paragraph{Interface} descrevem tipos cujo valores são referências de objetos distribuídos que oferecem a interface descrita.
\begin{samplecode}[language= {[CORBA]IDL} ]
interface Hello {
	attribute boolean quiet;
	readonly attribute long count;
	string say_hello_to(in string name);
};
\end{samplecode}

\paragraph{Exceção} descrevem tipos cujo valores são exceções que podem ser lançadas por operações em interfaces de objetos distribuídos.
\begin{samplecode}[language= {[CORBA]IDL} ]
exception DivisionByZero {
	long dividend;
	long divisor;
};
interface IntegerMath {
	long div(in long dividend, in long divisor, out long remainder)
		raises(DivisionByZero);
};
\end{samplecode}

\paragraph{Apelidos} descrevem nomes alternativos para definições de tipos.
\begin{samplecode}[language= {[CORBA]IDL} ]
typedef unsigned long Cardinal;
\end{samplecode}

\paragraph{Espaços de Nomes} descrevem espaços distintos para definições de novas declarações de forma que não conflitem com outras definições em outros espaços.
Utiliza-se o prefixo \code{tecgraf::} para referenciar declarações feitas no espaço de nomes (módulo) com o nome \code{tecgraf}.
\begin{samplecode}[language= {[CORBA]IDL} ]
module tecgraf {
	module openbus {
		interface SquareMatrix {};
	};
};
interface MyFactory {
  tecgraf::openbus::SquareMatrix newMatrix();
};
\end{samplecode}

\section{Ciclo de Vida de Objetos}

Assim como os objetos distribuídos de CORBA podem ser criados, eles também podem ser descartados de forma que não possam mais ser chamados remotamente.
É importante descartar objetos que não são mais utilizados pois os objetos distribuídos em geral ocupam algum recurso do ORB enquanto existentes.
CORBA não define um mecanismo de coleta ou descarte automático de objetos, portanto é necessário descartá-los explicitamente.
Por outro lado, CORBA define inúmeras formas de gerência do ciclo de vida de objetos.
Contudo, neste documento não faremos uma explanação extensiva sobre isso.
Ao invés disso apresentaremos um modelos mais simples e usual em que os objetos são criados e descartados explicitamente pela aplicação.

Para ilustrar isso consideremos agora que o nosso servidor deve exportar não apenas um objeto matriz, mas sim um objeto que funciona como uma fábrica de matrizes, que são criadas através de chamadas dos clientes.
A interface desse serviço de fábrica de matrizes é ilustrada na figura~\ref{fig:ex04:matrices}.
Nessa IDL também introduzimos algumas alterações na interface \code{SquareMatrix} de matrizes, que agora passa a lançar a exceção \code{WrongCardinality} para indicar um erro quando o tamanho do \code{Vector} não corresponde à cardinalidade da matriz (linha~\ref{lin:ex04:matrices:raiseexcept}).
Adicionalmente, a interface \code{SquareMatrix} apresenta a operação \code{dispose}, que deve ser chamada pelo cliente que cria uma matriz quando a mesma não é mais utilizada e pode ser descartada (linha~\ref{lin:ex04:matrices:disposeop}).
A nova interface \code{MatrixFactory} é a interface a ser implementada pelo objeto de fábrica de matrizes (linha~\ref{lin:ex04:matrices:factoryiface}).

\inputexidl{ex04}{matrices}{IDL de fábrica de matrizes de transformação.}

Agora podemos compilar essa nova IDL, usando por exemplo o compilador de IDL do próprio JDK através do seguinte comando:

\begin{samplecode}[language=bash]
	idlj -fallTIE matrices.idl
\end{samplecode}

Como resultado o compilador de IDL gerará código fonte Java que implementam definições em Java equivalentes às definições em IDL.
Em particular, temos classes que implementam as exceções declaradas em IDL.
Logo para lançar uma exceção CORBA definida em IDL basta criamos uma instância da classe Java gerada correspondente.
%A seguir há uma lista dos arquivos gerados pelo compilador de IDL do JDK~\footnote{Os arquivos com nomes que começam com \code{\_} podem ser gerados com outros nomes dependendo da versão do compilador.}:
%
%\begin{itemize}
% \item CardinalHelper.java
% \item MatrixIdHelper.java
% \item MatrixFactory.java
% \item MatrixFactoryHelper.java
% \item MatrixFactoryHolder.java
% \item MatrixFactoryOperations.java
% \item MatrixFactoryPOA.java
% \item MatrixFactoryPOATie.java
% \item ServiceFailure.java
% \item ServiceFailureHelper.java
% \item ServiceFailureHolder.java
% \item SquareMatrix.java
% \item SquareMatrixHelper.java
% \item SquareMatrixHolder.java
% \item SquareMatrixOperations.java
% \item SquareMatrixPOA.java
% \item SquareMatrixPOATie.java
% \item UnknownMatrixKind.java
% \item UnknownMatrixKindHelper.java
% \item UnknownMatrixKindHolder.java
% \item VectorHelper.java
% \item VectorHolder.java
% \item WrongCardinality.java
% \item WrongCardinalityHelper.java
% \item WrongCardinalityHolder.java
% \item \_MatrixFactoryStub.java
% \item \_SquareMatrixStub.java
%\end{itemize}

Para implementarmos essa nova IDL, um primeiro ponto a considerarmos é que agora a interface \code{SquareMatrix} não é mais inteiramente compatível com a interface local da classe \code{Matrix}, já que a exceção \code{WrongCardinality} nunca é lançada pela classe.
Para lançarmos essa exceção adotaremos uma abordagem ligeiramente diferente na implementação.
Ao invés de utilizarmos a classe \code{SquareMatrixPOATie} como um envoltório que adapta a classe \code{Matrix} para funcionar como um servant, agora implementaremos esse envoltório na classe \code{MatrixServant} extendendo a classe gerada \code{SquareMatrixPOA}, como ilustrado na figura~\ref{fig:ex04:matrices/Server:10:30}.
A classe \code{MatrixServant} recebe um objeto \code{Matrix} no construtor e delega todas as chamadas a dele, tal como a classe gerada \code{SquareMatrixPOATie} faz.
Contudo, nessa implementação de envoltório podemos lançar a exceção \code{WrongCardinality} na operação \code{multiply} se necessário (linha~\ref{lin:ex04:matrices/Server:raiseexcept}), assim como implementar operações adicionais, como é o caso da operação \code{dispose}.
A implementação da operação \code{dispose} utiliza operações herdadas da classe gerada \code{SquareMatrixPOA} para obter o POA em que a matrix foi registrada e o identificador de objeto da matrix naquele POA para poder desátivá-lo (linha~\ref{lin:ex04:matrices/Server:deactivateobject}).

\inputexrange{ex04}{matrices/Server}{10}{30}{Envoltório do objeto \code{Matrix} que o adapta a interface CORBA.}

A mesma abordagem é utilizada na implementação da fáblica de matrizes como é ilustrado na figura~\ref{fig:ex04:matrices/Server:31:48}.
A classe \code{MatrixFactoryServant} extende a classe gerada \code{MatrixFactoryPOA}.
Mas nesse caso a implementação da operação \code{newMatrix} é implementada pela própria classe ao invés de delegar para um outro objeto como é feito no caso da classe \code{MatrixServant}.

\inputexrange{ex04}{matrices/Server}{31}{48}{Implementação de fábrica de matrizes.}

Para efetivamente criar um novo objeto \code{SquareMatrix} primeramente criamos o seu servant (linha~\ref{lin:ex04:matrices/Server:matrixservant}).
Utilizamos a operação \code{\_poa} herdada da classe \code{MatrixFactoryPOA} para obter o mesmo POA em que a fábrica foi registrada, e utilizamos esse POA para registrar a matriz sendo criada (linha~\ref{lin:ex04:matrices/Server:matrixobject}).

Para concluir nossa implementação do serviço de fábrica de matrizes, apenas alteramos a função \code{main} do servidor para criar e imprimir o IOR de uma fábrica de matrizes ao invés de uma única matriz, tal como ilustrado na figura~\ref{fig:ex04:matrices/Server:50:66}.

\inputexrange{ex04}{matrices/Server}{50}{66}{Servidor do serviço de fábrica de matrizes.}

A aplicação cliente deve também ser alterada para fazer uso da fábrica de matrizes, como ilustrado na figura~\ref{fig:ex04:matrices/Application:8:28}.
Agora o IOR lido da entrada padrão é uma referência para um objeto \code{MatrixFactory} ao invés de \code{SquareMatrix} (linha~\ref{lin:ex04:matrices/Application:getfactory}).
Para obtermos um objeto \code{SquareMatrix} chamamos a operação \code{newMatrix} do objeto da fábrica (linha~\ref{lin:ex04:matrices/Application:getmatrix}).
Ao final, descartamos a matrix através da operação \code{dispose} (linha~\ref{lin:ex04:matrices/Application:freematrix}).

\inputexrange{ex04}{matrices/Application}{8}{28}{Utilização da fábrica de matrizes.}
