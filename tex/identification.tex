Neste capítulo são apresentados diversos recursos oferecidos pela infraestrutura do \openbus{} para o desenvolvimento de integrações de sistemas através de exemplos de código que utilizam a biblioteca de acesso do \openbus{}.
Todos os exemplos são elaborados de forma incremental para formar ao final uma integração completamente funcional sobre a infraestrutura do \openbus{}.

\section{OpenBus SDK}

O \openbus{} oferece um kit de desenvolvimento de software (SDK) com ferramentas para facilitar o desenvolvimento e integrações via \openbus{}.
O \openbus{} SDK é composto por:

\begin{itemize}
	\item Compilador de IDL.
	\item Biblioteca de acesso.
	\item Classes utilitárias.
	\item Documentação.
	\item Aplicações de demonstração.
\end{itemize}

O compilador de IDL disponibilizado é provido por pela implementação de ORB utilizada pelo SDK.
Por exemplo, no OpenBus SDK para Java o ORB utilizado é o JacORB.

O principal componente do SDK é a biblioteca de acesso.
Essa biblioteca permite a criação e utilização de ORB CORBA estendido com os recursos adicionais introduzidos pelo \openbus{}.
A principal função dessa biblioteca é facilitar o acesso a esses recursos particulares do \openbus{} através de uma API simples e flexível.

O SDK também inclui classes utilitárias para cenários de uso específicos do \openbus{}, tal como o \term{Assistente}, que automatiza tarefas rotineiras no caso de integrações mais simples.
O Assistente é discutido na seção \ref{sec:assistant}.

O SDK também inclui arquivos de documentação e aplicações de demonstração.

\section{Iniciando o ORB}

Um ORB OpenBus é iniciado através da operação \code{initORB}, cuja assinatura é apresentada abaixo.

\begin{samplecode}
  public class ORBInitializer {
    public static ORB initORB();
    public static ORB initORB(String[] args);
    public static ORB initORB(String[] args, Properties props);
  }
\end{samplecode}

A operação \code{initORB} tem o mesmo funcionamento da operação \code{CORBA::init} do padrão CORBA, exceto que ela inicia e retorna um ORB com os recursos adicionais do \openbus{}.
Por exemplo, podemos fazer os programas dos execícios anteriores utilizarem um ORB OpenBus apenas trocando a chamada de \code{CORBA::init} para \code{ORBInitlializer::initORB}, como ilustrado na figura~\ref{fig:ex05:matrices/Server:52:66} (linha~\ref{lin:ex05:matrices/Server:initorb}).
Contudo, para tanto é necessário compilar o programa com as bibliotecas e ferramentas disponibilizadas pelo SDK.
Em particular, é necessário utilizar o compilador de IDL do SDK e as bibliotecas disponibilizadas.

\inputexrange{ex05}{matrices/Server}{52}{66}{Servidor com ORB OpenBus.}

Para compilar a IDL \code{matrices.idl} utilizando o compilador de IDL do OpenBus SDK para Java utilize o seguinte comando:

\begin{samplecode}[language=bash,escapechar=]
java -cp $ODK_HOME/lib/jacorb-idl-compiler-3.5.jar org.jacorb.idl.parser matrices.idl
\end{samplecode}

Para compilar os programas para utilizarem a biblioteca de acesso, utilize o seguinte comando:

\begin{samplecode}[language=bash,escapechar=]
javac -cp "$ODK_HOME/lib/jacorb-3.5.jar\
:$ODK_HOME/lib/jacorb-omgapi-3.5.jar\
:$ODK_HOME/lib/openbus-sdk-core-2.0.2.0.jar\
:$ODK_HOME/lib/openbus-sdk-legacy-2.0.2.0.jar\
:$ODK_HOME/lib/scs-core-1.2.1.3.jar\
:$ODK_HOME/lib/slf4j-api-1.7.6.jar\
:$ODK_HOME/lib/slf4j-jdk14-1.7.6.jar" \
    tecgraf/openbus/demo/matrices/Server.java \
    tecgraf/openbus/demo/matrices/Application.java
\end{samplecode}

Por fim, para executar esses processos você pode fazer:

\begin{samplecode}[language=bash,escapechar=]
java -Djava.endorsed.dirs=$ODK_HOME/lib \
  tecgraf.openbus.demo.matrices.Server > ref.ior
java -Djava.endorsed.dirs=$ODK_HOME/lib \
  tecgraf.openbus.demo.matrices.Application < ref.ior
\end{samplecode}

Contudo, os programas agora devem lançar uma exceção de \code{CORBA::NO\_PERMISSION}.
Isso acontece porque um ORB OpenBus só permite chamadas através de um barramento, que só podem ser feitas após a autenticação da aplicação em nome de uma entidade.

O ORB OpenBus notifica diversas situações anômalas nas chamadas remotas através da exceção \code{CORBA::NO\_PERMSSION}, contendo códigos numéricos específicos que identificam o cenário exato da exceção, conforme ilustrado na tabela abaixo:

{\footnotesize
\begin{tabular}{l|c|c|r|l}
  Nome & Valor & vmcid & minor & Descrição \\
  \hline
  NoCredential      & 1112888070 & 0x42555000 & 774  & chamada feita sem credencial \\
  NoLogin           & 1112888319 & 0x42555000 & 1023 & sem conexão autenticada no barramento \\
  InvalidChain      & 1112888065 & 0x42555000 & 769  & cadeia de chamadas inválida \\
  InvalidPublicKey  & 1112888069 & 0x42555000 & 773  & alvo informou chave pública inválida \\
  InvalidRemote     & 1112888318 & 0x42555000 & 1022 & alvo não respeita o protocolo \\
  InvalidTarget     & 1112888316 & 0x42555000 & 1020 & alvo com login inválido \\
  UnavailableBus    & 1112888317 & 0x42555000 & 1021 & alvo sem acesso ao barramento \\
  UnknownBus        & 1112888068 & 0x42555000 & 772  & alvo está em outro barramento \\
  UnverifiedLogin   & 1112888067 & 0x42555000 & 771  & alvo não pôde verificar o login \\
\end{tabular}
}

Assim como a exceção \code{CORBA::NO\_PERMISSION}, as chamadas remotas de CORBA podem lançar outras exceções para indicar outras condições anômalas, tipicamente relacionadas a problemas de comunicação em rede, tais como listadas na tabela abaixo:

\begin{tabular}{l|l}
  Nome                      & Descrição \\
  \hline
  CORBA::UNKNOWN            & erro que não pode ser mapeado para CORBA \\
  \hline
  CORBA::OBJECT\_NOT\_EXIST & objeto referenciado não existe \\
  CORBA::TRANSIENT          & falha transiente, tente novamente \\
  CORBA::COMM\_FAILURE      & falha de comunicação \\
  \hline
  CORBA::MARSHAL            & erro na codificação dos valores \\
  CORBA::NO\_IMPLEMENT      & implementação da operação indisponível \\
  CORBA::BAD\_OPERATION     & operação chamada é inválida \\
  \hline
  CORBA::BAD\_INV\_ORDER    & invocação fora de ordem \\
  CORBA::BAD\_PARAM         & parâmetro inválido \\
\end{tabular}

\section{O Contexto OpenBus}

Todo ORB OpenBus tem associado um objeto especial denominado de contexto.
Esse objeto contexto permite definir informações de autenticação e identificação de chamadas para o contexto de execução atual.
O contexto de execução atual em geral se reflete na thread (linha de execução) atual do programa.
Basicamente utilizamos o contexto para definir a identidade com que as chamadas feitas usando a thread atual serão feitas através do barramento OpenBus.
O contexto OpenBus do ORB é obtido da seguinte forma:

\begin{samplecode}[language=java]
org.omg.CORBA.ORB orb = ORBInitializer.initORB();
tecgraf.openbus.OpenBusContext context =
  (tecgraf.openbus.OpenBusContext)
    orb.resolve_initial_references("OpenBusContext");
\end{samplecode}

Através do contexto criamos e manipular conexões com o barramento.
A interface do objeto de contexto do OpenBus é apresentada seguir:

\begin{samplecode}[language=java]
public interface OpenBusContext {
  ...
  Connection createConnection(String bus_host, int bus_port);
  Connection createConnection(String bus_host, int bus_port,
                              Properties props) throws InvalidPropertyValue;

  Connection setDefaultConnection(Connection conn);
  Connection getDefaultConnection();

  Connection setCurrentConnection(Connection conn);
  Connection getCurrentConnection();
  ...      
}
\end{samplecode}

\section{Manipulando Conexões} \label{sec:ConnManage}

A criação de novas conexões é feita através da operação \code{createConnection}, que recebe o endereço da máquina e o número da porta onde os serviços básicos daquele barramento executam.
Opicionalmente a operação \code{createConnection} recebe uma lista de propriedades que podem ser usadas para definir outros aspectos da conexão, tal como suporte à interoperabilidade com outros serviços que utilizem versões legadas do OpenBus e parâmetros de ajuste de desempenho.

Os objetos conexão são usados para representar formas de acesso a um barramento, que basicamente se resume a identidade com que se acessa o barramento.
Muitas vezes um dado sistema só cria uma única conexão e a utiliza para acessar o barramento sempre da mesma forma, ou seja, com a mesma identidade.
Nesse caso utilizamos a operação \code{setDefaultConnection} para definir a conexão padrão a ser utilizadas nas chamadas através daquele ORB.
Alternativamente, podemos usar a operação \code{setCurrentConnection} para definir uma conexão específica para o contexto atual (linha de execução), sobreescrevendo a conexão padrão para aquela linha de execução.

Para utilizarmos por padrão uma conexão para o barramento cujos serviços básicos executam na máquina \code{bushost} e na porta 20000, podemos utilizar o seguinte código:

\begin{samplecode}[language=java]
Connection conn = context.createConnection("bushost", 20000);
context.setDefaultConnection(conn);
\end{samplecode}

\section{Autenticação por Senha}

Para serem utilizadas em chamadas, as conexões devem primeiramente serem autenticadas em nome de uma entidade.
Uma forma de fazer isso é através da operação \code{loginByPassword} da conexão, informando o nome da entidade e a senha.
Ao executar essa operação com sucesso, a conexão está autenticada e poderá ser usada para fazer chamadas usando como identidade o nome da entidade autenticada.
A seguir são apresentadas algumas das operações da conexão relacionadas a autenticação:

\begin{samplecode}[language=java]
public interface Connection {
  ...
  org.omg.CORBA.ORB orb();
  String busid();
  LoginInfo login();

  void loginByPassword(String entity, byte[] password) throws AlreadyLoggedIn,
                                                              AccessDenied,
                                                              ServiceFailure;

  boolean logout() throws ServiceFailure;
  ...
}
\end{samplecode}

A operação \code{orb} devolve o ORB a ser usado nas chamadas com essa conexão.
A operação \code{logout} é usada para encerrar a autenticação da conexão e revogar o seu login, tornando inválidas todas as futuras chamadas pelo barramento utilizando essa identidade (login).
Enquanto a conexão estiver autenticada ela possui um login associado, cujas informações podem ser obtidas através da operação \code{login}.
Similarmente, a operação \code{busid} informa o identificador do barramento em que conexão estiver autenticada.
Caso a conexão tenha sua autenticação (login) revogada ou nunca tenha sido autenticada, as operações \code{login} e \code{busid} devolvem valores nulos.
A seguir é apresentado um trecho de código que se autentica no barramento com o nome de entidade \code{SomeoneUser} e imprime o identificador de login gerado no processo de autenticação.

\begin{samplecode}[language=java]
conn.loginByPassword("SomeoneUser", ("Someone").getBytes());
System.out.println("Meu login em "+conn.busid()+" é "+conn.login().id);
conn.logout();
\end{samplecode}

Para adaptar uma aplicação CORBA para fazer chamadas através do barramento, tal como a nossa aplicação de matrizes, basta fazermos algumas pequenas mudanças, como ilustrado na figura~\ref{fig:ex06:matrices/Application:16:46}.
Primeiramente, passaremos a utilizar um ORB iniciado pela biblioteca do SDK (linha~\ref{lin:ex06:matrices/Application:initorb}).
A partir do ORB obtemos o objeto de contexto do OpenBus associado àquele ORB, para que possamos definir o contexto de identificação das chamadas OpenBus através daquele ORB (linha~\ref{lin:ex06:matrices/Application:getcontext}).
A partir do contexto podemos criar uma conexão para um barramento específico informando a máquina e porta dos serviços núcleo do barramento desejado (linha~\ref{lin:ex06:matrices/Application:createconn}).
Como nossa aplicação é simples o suficiente para que todas as chamadas sejam feitas para um único barramento e usando uma mesma identidade sempre, definimos essa conexão como a conexão default a ser utilizada em todas as comunicações através aquele ORB (linha~\ref{lin:ex06:matrices/Application:setdefconn}).
Contudo, antes realizar chamadas através dessa conexão é necessário autenticá-la em nome de alguma entidade, por exemplo através de uma senha usando a operação \code{loginByPassword} (linha~\ref{lin:ex06:matrices/Application:loginconn}).
Também é importante chamar a operação \code{logout} quando a conexão não for mais utilizada para facilitar com que os recursos alocados para manutenção da autenticação sejam liberados (linha~\ref{lin:ex06:matrices/Application:logoutconn}).

\inputexrange{ex06}{matrices/Application}{16}{46}{Aplicação de matrizes com login por senha.}

\section{Autenticação por Certificado}

Alternativamente, a conexão também pode ser autenticada através de uma chave privada correspondente a um certificado registrado no barramento.
Essa forma de autenticação é tipicamente mais adequada para autenticação de sistemas, visto que para uma instalação de sistema guardar uma chave gerada computacionalmente é equivalente a guardar uma senha elaborada por um humano.
Contudo, uma chave pode ser bem mais segura que uma senha se gerada de forma adequada como veremos mais a frente.
A seguir são apresentadas algumas as operações relacionadas a autenticação via chave e certificado.

\begin{samplecode}[language=java]
public final class Cryptography {
  public static synchronized Cryptography getInstance();
  public RSAPrivateKey readKeyFromFile(String fileName)
    throws IOException, InvalidKeySpecException, CryptographyException;
  public RSAPrivateKey readKeyFromBytes(byte[] prvKeyByteArray)
    throws InvalidKeySpecException, CryptographyException;
}

public interface Connection {
  void loginByCertificate(String entity, RSAPrivateKey privateKey)
    throws AlreadyLoggedIn, AccessDenied, MissingCertificate, ServiceFailure;
  ...
\end{samplecode}

A classe \code{Cryptography} oferece funções utilitárias para facilitar a leitura de chaves privadas a partir de um arquivo ou se um array de bytes.
Alternativamente, é possível utilizar as próprias classes do Java para obter a chave ser utilizada na autenticação por chave e certificado.
A operação \code{loginByCertificate} recebe o nome da entidade a ser autenticada e a chave privada correspondente ao certificado registrado no barramento para essa entidade.
Por essa razão, é necessário gerar e registrar no barramento um certificado e chave para cada sistema que utilize essa forma de autenticação.
Isso pode ser feito utilizando o utilitário de linha de comando do projeto de código aberto OpenSSL (versão 1.0.0 ou maior), que vem instalado em muitas plataformas.
Por exemplo, para gerar um par de chave (\code{private.key}) e certificado auto-assinado (\code{system.crt}) para uso na autenticação no OpenBus, é possível utilizar os seguintes comandos do OpenSSL:

\begin{samplecode}[language=bash]
openssl genrsa -out tmp.key 2048
openssl pkcs8 -topk8 -nocrypt -in tmp.key \
        -out private.key -outform DER
openssl req -new -x509 \
        -key private.key -keyform DER \
        -out system.crt -outform DER
\end{samplecode}

Tal como uma senha, é importante garantir que a chave privada gerada só possa ser lida pelo sistema que se autenticará com ela, para evitar que outros possam se autenticar usando a chave.
Por isso, sugere-se apagar o arquivo \code{tmp.key} gerado e só dar permissão de leitura ao arquivo \code{private.key} para o usuário do sistema que executará o sistema a ser autenticado.
Finalmente envie o certificado público gerado \code{system.crt} para o gerente do barramento para que ele seja registrado para autenticação da entidade com que o sistema será autenticado.
Veremos na seção~\ref{sec:addcertificate} como um administrador registra um certificado de autenticação no barramento.
Uma vez feito isso, podemos adaptar nosso servidor de matrizes para que ele se autentique ao barramento usando a chave privada gerada \code{private.key}, conforme ilustrado na figura~\ref{fig:ex07:matrices/Server:60:87}.
Inicialmente fazemos a leitura da chave private usando a função utilitária \code{createPrivateKeyFromFile} (linha~\ref{lin:ex07:matrices/Server:readkey}).
Em seguida, tal como no exemplo da figura~\ref{fig:ex06:matrices/Application:16:46}, inicamos um ORB com suporte ao OpenBus (linha~\ref{lin:ex07:matrices/Server:initorb}), obtemos o objeto de contexto do ORB (linha~\ref{lin:ex07:matrices/Server:getcontext}), criamos uma conexão para um barramento específico (linha~\ref{lin:ex07:matrices/Server:createconn}) e definimos essa conexão como a conexão default a ser utilizada em todas as comunicações através aquele ORB (linha~\ref{lin:ex07:matrices/Server:setdefconn}).
Contudo, a autenticação é feita através da chave privada usando a operação \code{loginByCertificate} (linha~\ref{lin:ex07:matrices/Server:loginconn}).
Novamente, como no exemplo da figura~\ref{fig:ex07:matrices/Server:60:87}, é importante chamar a operação \code{logout} quando a conexão não for mais utilizada para facilitar com que os recursos alocados para manutenção da autenticação sejam liberados (linha~\ref{lin:ex07:matrices/Server:logoutconn}).

\inputexrange{ex07}{matrices/Server}{60}{87}{Servidor de matrizes com login por certificado.}

\section{Autenticação Compartilhada}

Em alguns cenários, pode ser necessário que um sistema compartilhe sua autenticação com outro sistema.
Por exemplo, se uma aplicação autenticada como um usuário precisar disparar outra aplicação em nome desse usuário sem que seja necessário pedir a senha do usuário novamente.
Para esses casos o OpenBus permite gerar um token para o compartilhamento de uma autenticação.
O token só pode ser gerado através de conexões autenticadas e só pode ser usado uma única vez para autenticar outra conexão com autenticação da conexão original usada para geração do token.
O token também tem um tempo de validade curto, que é configurado pelo gerente do barramento.
A seguir são apresentadas as operações para manipulação de tokens de autenticação compartilhada.

\begin{samplecode}[language=java]
public interface Connection {
  ...
  SharedAuthSecret startSharedAuth() throws ServiceFailure;

  void loginBySharedAuth(SharedAuthSecret secret)
    throws AlreadyLoggedIn,
           InvalidLoginProcess,
           AccessDenied,
           ServiceFailure;
  ...

public interface OpenBusContext {
  byte[] encodeSharedAuth(SharedAuthSecret secret);
  SharedAuthSecret decodeSharedAuth(byte[] encoded)
    throws InvalidEncodedStream;
  ...
\end{samplecode}

A operação \code{startSharedAuth} da conexão é utilizada para criar um novo token de autenticação compartilhada (\code{SharedAuthSecret}).
De posse de um token, é possível utilizá-lo na chamada de \code{loginBySharedAuth} para autenticar uma conexão que ainda não esteja autenticada.
Adicionalmente, o objeto de contexto também oferece operações para serialização num array de bytes (\code{encodeSharedAuth}) e recuperação a partir desse array de bytes (\code{decodeSharedAuth}) de um token de autenticação compartilhada.
O código abaixo ilustra a utilização dessas operações para compartilhar uma autenticação entre duas conexões.

\begin{samplecode}[language=java]
  SharedAuthSecret secret = conn1.startSharedAuth();
  writeToPrivateFile("token.dat", context.encodeSharedAuth(secret));
  ...
  byte[] encoded = readFromPrivateFile("token.dat");
  conn2.loginBySharedAuth(context.decodeSharedAuth(encoded));
\end{samplecode}

\section{Identificação da Origem das Chamadas}

O OpenBus só permite chamadas autenticadas nas comunicações através do barramento.
Contudo, uma vez autenticado com qualquer entidade, qualquer sistema é capaz de iniciar qualquer chamada através do barramento.
É responsabilidade de cada implementação de serviço que recebe uma chamada avaliar a identidade da origem da chamada e avaliar se a chamada pode prosseguir ou se deve ser interrompida através do lançamento de uma exceção por exemplo.
A informação sobre a identidade da oridem de uma chamada em execução pode ser obtida através da operação \code{getCallerChain} do objeto de contexto, cuja interface é apresentada abaixo.

\begin{samplecode}[language=java]
public interface OpenBusContext {
  ...
  CallerChain getCallerChain();
  ...      
}

public interface CallerChain {
  String busid();
  String target();
  LoginInfo[] originators();
  LoginInfo caller();
}
\end{samplecode}

A operação \code{getCallerChain} devolve um objeto com as informações de identidade de todos os participantes da cadeia de chamadas que originou a chamada atual.
Dizemos que é uma cadeia de chamadas, pois a chamada pode fazer parte de outras operações executadas de forma aninhadas em outros sistemas, onde cada sistema responsável cada chamada nessa cadeia pode ter uma identidade diferente.
A operação \code{caller} devolve as informações de login, tal como identificador do login e nome da entidade de autenticação, do sistema que realizou a chamada sendo despachada.
Já a operação \code{originators} devolve uma lista de informações de login de outros sistemas que originaram indiretamente a chamada, tipicamente pelo recebimento de outras chamadas que originaram a chamada atual.
As operações \code{busid} e \code{target} devolvem os identificadores do barramento e do login da conexão através do qual a chamada foi recebida, o que é útil em aplicações que fazem uso de múltiplas conexões com múltiplos barramentos ou identidades.

Para ilustrar isso, consideremos alternar o nosso servidor de matrizes para que ele só aceite chamadas provenientes de sistemas autenticados com a entidade \code{MatricesUser}.
A figura~\ref{fig:ex09:matrices/Server:53:81} ilustra a implementação da fábrica de matrizes fazendo uso da identificação da origem das chamadas para recusar chamadas de origens não autenticadas.
Inicialmente, obtemos o objeto de contexto do OpenBus para o ORB que recebeu a chamada (linha~\ref{lin:ex09:matrices/Server:getctxt}).
A partir da operação \code{getCallerChain} do objeto de contexto obtermos todas as identidades originadoras daquela cadeia de chamadas, e a operação \code{caller} devolve a identidade de quem efetivamente fez a chamada atual (linha~\ref{lin:ex09:matrices/Server:getcaller}).
Na linha~\ref{lin:ex09:matrices/Server:checkcaller} testamos se a entidade de origem da chamada não é a esperada e lançamos uma exceção de \code{NO\_PERMISSION} para impedir que achamada prossiga (linha~\ref{lin:ex09:matrices/Server:noperm}).

\inputexrange{ex09}{matrices/Server}{53}{81}{Fábrica de matrizes com identificação de chamada.}

Adotamos essa abordagem para adaptar as implementações das operações dos objetos de matrizes, como ilustrado na figura~\ref{fig:ex09:matrices/Server:18:51}.
Na linha~\ref{lin:ex09:matrices/Server:authimpl} declaramos uma operação privada que faz a validação da origem da chamada tal como na figura~\ref{fig:ex09:matrices/Server:53:81}.
Em seguida, chamamos essa operação de validação nas implementações das operações \code{multiply} (linha~\ref{lin:ex09:matrices/Server:authmultiply}) e \code{dispose} (linha~\ref{lin:ex09:matrices/Server:authdispose}) para garantir que elas só executem por completo quando iniciadas por um sistema devidamente autenticado.

\inputexrange{ex09}{matrices/Server}{18}{51}{Operações das matrizes com identificação de chamada.}

Fica como exercício para o leitor adaptar a aplicação cliente para que ela tente executar uma operação com a identidade errada para validar a implementação do servidor com identificação da origem da chamada.

\paragraph{Dica:}
\begin{itemize}
  \item Utilize a operação \code{setCurrentConnection} do \code{OpenBusContext} para definir a segunda conexão como a conexão corrente antes de fazer a chamada \code{SquareMatrix::multiply}.
  \item Não faça logout na primeira conexão para poder utilizá-la para chamar \code{SquareMatrix::dispose} antes de terminar a execução.
\end{itemize}

\section{Inspeção da Cadeia de Chamadas}

Da mesma forma que é possível recusar chamadas com base na identidade da entidade que o sistema que faz a chamada está autenticado, também é possível levar em consideração outras identidades na cadeia de chamadas.
Para ilustrar isso, consideremos agora um serviço adicional para fornecer dados para criação das matrizes, cuja interface é ilustrada na figura~\ref{fig:ex11:transformations}.
A operação \code{listTransformations} (linha~\ref{lin:ex11:transformations:listtypes}) devolve a lista de todas os tipos de matrizes que o serviço pode fornecer dados, e a operação \code{getTransformation} (linha~\ref{lin:ex11:transformations:getdata}) permite obter os dados da matriz na forma de uma sequencia de valores que compõe a matriz.
O intuito desse novo serviço é ser utilizado pelo serviço de fábrica de matrizes na construção de novas matrizes.
Dessa forma, quando a aplicação cliente utiliza a fábrica de matrizes para criar um novo objeto, a fábrica acessa o provedor de dados para obter os dados para criação da nova matriz.
Nesse cenário, o provedor de dados pode avaliar se aceita a chamada não apenas com base na identidade do serviço de fábrica de matrizes, mas também levando em conta a identidade da aplicação cliente que solicitou a criação de uma nova matriz.

\inputexidl{ex11}{transformations}{IDL de provedor de dados de matrizes.}

Como exemplo disso, considere a figura~\ref{fig:ex26:transformations/Server:35:81} que ilustra parte da implementação desse serviço adicional.
A operação privada \code{assertAuthorized} (linha~\ref{lin:ex26:transformations/Server:auxfunc}) obtém a cadeia de chamada (linha~\ref{lin:ex26:transformations/Server:getchain}) e a partir dela obtém a identidade de quem realizou a chamada (linha~\ref{lin:ex26:transformations/Server:getcaller}).
Adicionalmente, também é obitida a lista de demais originadores participando nessa cadeia de chamadas (linha~\ref{lin:ex26:transformations/Server:listorigins}).
É então feita uma validação da identidade de quem realizou a chamada (linha~\ref{lin:ex26:transformations/Server:checkcaller}), que se espera que seja a entidade do serviço de fábrica de matrizes.
Também é feita uma verificação de que há apenas uma única entidade adicional envolvida na chamada (linha~\ref{lin:ex26:transformations/Server:countorigins}), que deveria ser a entidade da aplicação cliente que originou a criação da nova matriz.
Por fim, a operação \code{assertAuthorized} recupera essa identidade (linha~\ref{lin:ex26:transformations/Server:getorigin}) e a valida (linha~\ref{lin:ex26:transformations/Server:checkorigin}).

\inputexrange{ex26}{transformations/Server}{35}{81}{Serviço de provedor de dados de matrizes.}

\section{Junção de Cadeias de Chamada}

Para realizar uma chamada combinando sua identidade com outra, é necessário obter uma cadeia de chamadas contendo as demais identidades e então fazer uma junção da sua identidade com essa cadeia.
Isso é feito através de operações do objeto de contexto como ilustrado abaixo.

\begin{samplecode}
  public interface OpenBusContext {
    ...

    void joinChain(CallerChain chain);
    void joinChain();

    void exitChain();

    CallerChain getJoinedChain();

    ...      
  }
\end{samplecode}

A operação \code{joinChain} permite definir a cadeia a ser mesclada com a identidade atual (que é definida pela conexão atual, como visto na seção~\ref{sec:ConnManage}) para compor todas as chamadas sendo feitas no contexto atual (linha de execução).
Ou seja, todas as chamadas remotas seguintes são feitas usando a identidade da conexão atual (\code{caller}) em conjunto com todas as identidades da cadeia passada para operação \code{joinChain} (\code{originators}).
A operação \code{joinChain} sendo chamada sem nenhum parâmetro é equivalente a \code{OpenBusContext.joinChain(OpenBusContext.getCallerChain())}.
A operação \code{exitChain} remove a cadeia de chamadas definida para o contexto atual, e é equivalente a \code{OpenBusContext.joinChain(null)}.
Por fim, a operação \code{getJoinedChain} é usada para obter a cadeia de chamadas definida para o contexto atual.

A figura~\ref{fig:ex12:matrices/Server:89:129} ilustra a adaptação do servidor de matrizes para obter uma refência para o serviço de provedor de dados (linha~\ref{lin:ex12:matrices/Server:getref}) e repassá-la para a fábrica de matrizes (linha~\ref{lin:ex12:matrices/Server:passref}).

\inputexrange{ex12}{matrices/Server}{89}{129}{Servidor de fábrica de matrizes obtendo referência para serviço de dados.}

A figura~\ref{fig:ex12:matrices/Server:53:87} ilustra as alterações na fábrica de matrizes para armazenar a referência do serviço (linha~\ref{lin:ex12:matrices/Server:saveref}) e utilizá-la para obter os dados (linha~\ref{lin:ex12:matrices/Server:callservice}) para criação de uma matriz (linha~\ref{lin:ex12:matrices/Server:creatematrix}).
Contudo, para que o acesso ao serviço de dados seja realizado com as identidades necessárias para que seja autorizado, é necessário antes fazer a junção da cadeia de chamadas correspondente à chamada atual, o que é feito através da operação \code{joinChain} (linha~\ref{lin:ex12:matrices/Server:joinchain}).

\inputexrange{ex12}{matrices/Server}{53}{87}{Fábrica de matrizes utilizando serviço de dados.}

\section{Observadores de Login}

Os sistemas que acessam o barramento possuem um login que eventualmente se torna inválido caso o sistema seja encerrado ou perca acesso ao barramento.
Devido a isso, observar o login de determinados sistemas pode ser muito útil na gerência dos recursos alocados pelo sistema.
Por exemplo, o nosso servidor de matrizes permite que os sistemas que o accessem possam criação de objetos de matrizes, que ficam válidos permanentemente.
Logo, se alguns sistemas criam matrizes e terminam sem destruir a matriz, isso poderia gerar muitos objetos matriz no servidor que esgotem os recursos do servidor.
Uma forma de contornar isso é atrelar a vida dos objetos de matriz ao tempo que o login do sistema que criou a matriz permanece válido.
Dessa forma, é possível garantir que a destruição das matrizes ocorreria pelo menos quando o sistema que as cria deixa de acessar o barramento.
Do lado dos clientes, basta que se realoque os recursos (recriar as matrizes) sempre que precisar relogar.

Para dar suporte a isso, o OpenBus oferece um serviço de observação de login acessível através da operação \code{OpenBusContext.getLoginRegistry}, cuja interface é describa abaixo em IDL de CORBA.

\begin{samplecode}[language= {[CORBA]IDL} ]
  interface OpenBusContext {
    LoginRegistry getLoginRegistry();
    ...      
  };

  interface LoginRegistry {
    LoginObserverSubscription subscribeObserver(in LoginObserver callback)
      raises (ServiceFailure);
    ...
  };

  interface LoginObserver {
    void entityLogout (in LoginInfo login);
  };

  interface LoginObserverSubscription {

    boolean watchLogin(in Identifier loginId)
      raises (ServiceFailure);

    void forgetLogin(in Identifier loginId)
      raises (ServiceFailure);

    void watchLogins(in IdentifierSeq loginIds)
      raises (InvalidLogins, ServiceFailure);

    void forgetLogins(in IdentifierSeq loginIds)
      raises (ServiceFailure);

    LoginInfoSeq getWatchedLogins();

    void remove()
      raises (ServiceFailure);

  };
\end{samplecode}

A operação \code{subscribeObserver} permite registrar um objeto observador a ser notificado sempre que determinados logins se tornarem inválidos através da operação \code{entityLogout}.
O resultado dessa operação é um objeto que permite definir os logins de interesse cuja invalidação deve ser notificada ao objeto observador.
As operações \code{watchLogin} e \code{watchLogins} permitem adicionar logins de interesse.
Enquanto as operações \code{forgetLogin} e \code{forgetLogins} permitem remover os logins de interesse adicionados.
A operação \code{getWatchedLogins} devolve os logins de interesse atuais, e a operação \code{remove} cancela o registro do objeto observador e todos seus logins de interesse, evitando que futuras notificações a esse observador sejam feitas.

Para adaptar nossa implementação do servidor de matrizes para descartar automaticamente as matrizes, faremos com que esse servidor registre um observador e sempre que uma matriz for criada, o login de quem a cria é adicionado ao observador para que ele seja notificado quando o login expirar.
Isso é ilustrado na figura~\ref{fig:ex13:matrices/Server:68:92}.
Nessa implementação, o construtor do objeto da fábrica recebe um POA que é onde o observador é registrado (linha~\ref{lin:ex13:matrices/Server:poaarg}).
De forma complementar, o construtor passa a lançar exceções relativas ao registro de objetos CORBA no POA, mas que não devem ocorrer na prática, a menos por um erro de implementação (linha~\ref{lin:ex13:matrices/Server:newexcepts}).
Nesse construtor é criado um mapa para associar cada nome de entidade a todas os objetos matriz criados por ela (linha~\ref{lin:ex13:matrices/Server:ownertable}).
Cada entrada do mapa inclui um segundo mapa que associa cada matriz criada ao \term{object ID} que identifica o objeto CORBA correspondente.
Essa informação será utilizada na desativação dos objetos CORBA correspondentes às matrizes criadas por uma entidade quando a notificação do seu logout for recebida pelo observador (linha~\ref{lin:ex13:matrices/Server:deactivatematrix}).

\inputexrange{ex13}{matrices/Server}{68}{92}{Observador que descarta matrizes.}

A figura~\ref{fig:ex13:matrices/Server:105:151} ilustra como alteramos a operação de criação de matrizes para registrar as matrizes para o devido descarte em decorrência da notificação de logout.
Primeiramente, o construtor dos objetos de matriz passa a receber a fábrica e o login de quem requisitou sua criação (linha~\ref{lin:ex13:matrices/Server:informlogin}).
Isso será usado para que a matriz possa se retirar do mapa de matrizes da fábrica quando ela for descartada como ilustrado na figura~\ref{fig:ex13:matrices/Server:153:173}.
Uma vez criado o objeto da matriz, ele é ativado como objeto CORBA (linha~\ref{lin:ex13:matrices/Server:activatematrix}) e adicionado ao mapa de matrizes (linha~\ref{lin:ex13:matrices/Server:registermatrix}).
Caso alguma exceção seja lançada durante o registro da matriz no POA, então a mesma é removida do mapa de matrizes criadas (linhas~\ref{lin:ex13:matrices/Server:disposematrix1} e \ref{lin:ex13:matrices/Server:disposematrix2}).
Após o registro do objeto CORBA, o login que solicita a criação da matriz passa a ser observado (linha~\ref{lin:ex13:matrices/Server:watchlogin}), de forma que a matriz possa ser descartada quando esse login ficar inválido.
Caso ocorra uma exceção na observação do login, a matriz é descartada e uma exceção é sinalizada para o cliente indicando que não foi possível criar a matriz (linha~\ref{lin:ex13:matrices/Server:disposematrix3}).
De forma similar, se a operação \code{watchLogin} devolver o valor \code{false}, indicando que o login sendo observado já está inválido (linha~\ref{lin:ex13:matrices/Server:watchfail}), então a matriz também é descartada (linha~\ref{lin:ex13:matrices/Server:disposematrix4}) e uma exceção é sinalizada para o cliente.

\inputexrange{ex13}{matrices/Server}{105}{151}{Registrando matriz para descarte.}

\inputexrange{ex13}{matrices/Server}{153}{173}{Operação de descarte da matriz.}

Por fim, a figura~\ref{fig:ex13:matrices/Server:33:66} ilustra a nova implementação da classe \code{MatrixServant} em que o construtor recebe uma referência para o objeto de fábrica e o login que solicitou a criação da matriz(linha~\ref{lin:ex13:matrices/Server:savefactory} e \ref{lin:ex13:matrices/Server:savelogin}).
Essas informações são utilizadas na operação \code{dispose} da matriz para descartá-la da fábrica (linha~\ref{lin:ex13:matrices/Server:disposematrix}) e assim evitar que seja descartada automaticamente em virtude do logout do cliente.

\inputexrange{ex13}{matrices/Server}{33}{66}{Matriz que notifica descarte.}
